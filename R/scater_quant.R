## Wrappers for kallisto quantification of abundance of RNA-seq reads
## Adapted from scater package https://github.com/davismcc/scater

################################################################################
#' scater adapted functions
#'
#' These functions were adapted from the \code{scater} package,
#' (\url{https://github.com/davismcc/scater})
#' Davis McCarthy, September 2017 (on behalf of scater authors and contributors)
#'
#' Run the abundance quantification tool \code{kallisto} on a set of FASTQ
#' files. Requires \code{kallisto} (\url{http://pachterlab.github.io/kallisto/})
#' to be installed and a kallisto feature index must have been generated prior
#' to using this function. See the kallisto website for installation and basic
#' usage instructions.
#'
#' @param targets_file character string giving the path to a tab-delimited text
#' file with either 2 columns (single-end reads) or 3 columns (paired-end reads)
#' that gives the sample names (first column) and FastQ file names (column 2 and
#' if applicable 3). The file is assumed to have column headers, although these
#' are not used.
#' @param transcript_index character string giving the path to the kallisto
#' index to be used for the feature abundance quantification.
#' @param single_end logical, are single-end reads used, or paired-end reads?
#' @param output_prefix character string giving the prefix for the output folder
#' that will contain the kallisto results. The default is \code{"output"} and
#' the sample name (column 1 of \code{targets_file}) is appended (preceded by an
#' underscore).
#' @param fragment_length scalar integer or numeric giving the estimated
#' average fragment length. Required argument if \code{single_end} is \code{TRUE},
#' optional if \code{FALSE} (kallisto default for paired-end data is that the
#' value is estimated from the input data).
#' @param fragment_standard_deviation scalar numeric giving the estimated
#' standard deviation of read fragment length. Required argument if
#' \code{single_end} is \code{TRUE}, optional if \code{FALSE} (kallisto default
#' for paired-end data is that the value is estimated from the input data).
#' @param n_cores integer giving the number of cores (nodes/threads) to use for
#' the kallisto jobs. The package \code{parallel} is used. Default is 2 cores.
#' @param n_bootstrap_samples integer giving the number of bootstrap samples
#' that kallisto should use (default is 0). With bootstrap samples, uncertainty
#' in abundance can be quantified.
#' @param bootstrap_seed scalar integer or numeric giving the seed to use for
#' the bootstrap sampling (default used by kallisto is 42). Optional argument.
#' @param correct_bias logical, should kallisto's option to model and correct
#' abundances for sequence specific bias? Requires kallisto version 0.42.2 or
#' higher.
#' @param plaintext logical, if \code{TRUE} then bootstrapping results are
#' returned in a plain text file rather than an HDF5
#' \url{https://www.hdfgroup.org/HDF5/} file.
#' @param kallisto_version character string indicating whether or not the
#' version of kallisto to be used is \code{"pre-0.42.2"} or \code{"current"}.
#' This is required because the kallisto developers changed the output file
#' extensions and added features in version 0.42.2.
#' @param verbose logical, should timings for the run be printed?
#' @param dry_run logical, if \code{TRUE} then a list containing the kallisto
#' commands that would be run and the output directories is returned. Can be
#' used to read in results if kallisto is run outside an R session or to produce
#'  a script to run outside of an R session.
#' @param kallisto_cmd (optional) string giving full command to use to call
#' kallisto, if simply typing "kallisto" at the command line does not give the
#' required version of kallisto or does not work. Default is simply "kalliso".
#' If used, this argument should give the full path to the desired kallisto
#' binary.
#'
#' @details A kallisto transcript index can be built from a FASTA file:
#' \code{kallisto index [arguments] FASTA-file}. See the kallisto documentation
#' for further details.
#'
#' @return A list containing three elements for each sample for which feature
#' abundance has been quantified: (1) \code{kallisto_call}, the call used for
#' kallisto, (2) \code{kallisto_log} the log generated by kallisto, and (3)
#' \code{output_dir} the directory in which the kallisto results can be found.
#'
#' @name kallisto-wrapper
#' @rdname kallisto-wrapper
#'
#' @importFrom parallel makeCluster
#' @importFrom parallel stopCluster
#' @importFrom parallel parLapply
#' @importFrom parallel detectCores
#' @importFrom utils read.delim
#' @export
batchKallisto <- function(targets_file, transcript_index, single_end = TRUE,
                          results_dir = getwd(),
                          output_prefix = "output", fragment_length = NULL,
                          fragment_standard_deviation = NULL,
                          n_cores = 2, n_bootstrap_samples = 0,
                          bootstrap_seed = NULL, correct_bias = TRUE,
                          plaintext = FALSE, kallisto_version = "current",
                          verbose = TRUE, dry_run = FALSE,
                          kallisto_cmd = "kallisto") {
    targets_dir <- paste0(dirname(targets_file), "/")
    targets <- read.delim(targets_file, stringsAsFactors = FALSE, header = TRUE)
    if ( !(ncol(targets) == 2 || ncol(targets) == 3) )
        stop("Targets file must have either 2 columns (single-end reads) or
             3 columns (paired-end reads). File should be tab-delimited with
             column headers")
    if ( ncol(targets) == 2 && !single_end ) {
        warning("targets only has two columns; proceeding assuming single-end
                reads")
        single_end <- TRUE
    }
    if ( ncol(targets) == 3 && single_end ) {
        warning("targets only has three columns, but 'single_end' was TRUE;
                proceeding assuming paired-end reads")
        single_end <- FALSE
    }
    samples <- targets[,1]
    ## If we have single-end reads then fragment_length must be defined
    if ( single_end && is.null(fragment_length) )
        stop("If single-end reads are used, then fragment_length must be
             defined. Either a scalar giving the average fragment length to use for all
             samples, or a vector providing the ave fragment length for each sample.")
    else
        paired_end <- !single_end
    if ( single_end && is.null(fragment_standard_deviation) )
        stop("If single-end reads are used, then fragment_standard_deviation must be defined.")
    else
        paired_end <- !single_end
    if ( correct_bias && kallisto_version == "pre-0.42.2" )
        stop("Bias correction requires kallisto version 0.42.2 or higher.")
    ## Make sure that we'll be able to find the fastq files
    targets[, 2] <- paste0(targets_dir, targets[, 2])
    if ( ncol(targets) == 3 )
        targets[, 3] <- paste0(targets_dir, targets[, 3])
    ## check that result directory exists, if not, create at working directory
    if(!dir.exists(results_dir)){
        dir.create(results_dir)
    }
    outputFolder <- suppressWarnings(path.expand(paste(results_dir, output_prefix, sep = "/")))
    ## Generate calls to kallisto
    output_dirs <- paste(outputFolder, samples, sep = "_")
    kallisto_args <- paste("quant -i", transcript_index, "-o",
                           output_dirs, "-b", n_bootstrap_samples)
    names(kallisto_args) <- samples
    if ( single_end )
        kallisto_args <- paste(kallisto_args, "--single")
    if ( !is.null(fragment_length) )
        kallisto_args <- paste(kallisto_args, "-l", fragment_length)
    if ( !is.null(fragment_standard_deviation) )
        kallisto_args <- paste(kallisto_args, "-s", fragment_standard_deviation)
    if ( !is.null(bootstrap_seed) )
        kallisto_args <- paste0(kallisto_args, " --seed=", bootstrap_seed)
    if ( correct_bias && kallisto_version != "pre-0.42.2" )
        kallisto_args <- paste0(kallisto_args, " --bias")
    if ( plaintext ) # output bootstrap results in a plaintext file
        kallisto_args <- paste0(kallisto_args, " --plaintext" )
    kallisto_args <- paste(kallisto_args, targets[, 2])
    if (paired_end)
        kallisto_args <- paste(kallisto_args, targets[, 3])
    ##
    if ( dry_run ) {
        kallisto_log <- vector("list", length(samples))
        names(kallisto_log) <- samples
        kallisto_calls <- paste("kallisto", kallisto_args)
        for (i in seq_len(length(kallisto_calls))) {
            kallisto_log[[i]]$output_dir <- output_dirs[i]
            kallisto_log[[i]]$kallisto_call <- kallisto_calls[i]
            kallisto_log[[i]]$kallisto_log <-
                "Dry run: kallisto commands not executed."
        }
    } else {
        if (verbose)
            print(paste("Analysis started: ", Sys.time()))
        detectedCores <- detectCores()
        if(n_cores > detectedCores){
            warning(paste0("Number of cores specified exceeds the detected ", detectedCores, " cores! Using default of 2 cores."))
            n_cores <- 2
        }
        cl <- parallel::makeCluster(n_cores)
        # one or more parLapply calls to kallisto
        kallisto_log <- parallel::parLapply(cl, kallisto_args, .call_kallisto,
                                            kallisto_cmd, verbose)
        parallel::stopCluster(cl)
        ## Return log of kallisto jobs, so user knows where to find results
        names(kallisto_log) <- samples
        if (verbose) {
            print(paste("Analysis completed: ", Sys.time()))
            print(paste("Processed", length(samples), "samples"))
        }
        for (i in seq_len(length(kallisto_log))) {
            kallisto_log[[i]]$output_dir <- output_dirs[i]
        }
    }
    kallisto_log
    ## fix any escape characters in .json files (possibly windows-only problem)
    .fix_escape(output_dir = results_dir)
}

.call_kallisto <- function(kcall, kallisto_cmd, verbose=TRUE) {
    out <- tryCatch(ex <- system2(kallisto_cmd, kcall, stdout = TRUE,
                                  stderr = TRUE),
                    warning = function(w){w}, error = function(e){e})
    list(kallisto_call = paste(kallisto_cmd, kcall), kallisto_log = out)
}

.fix_escape <- function(output_dir){
    json_dir <- list.files(path = output_dir, pattern = ".json", recursive = TRUE, full.names = TRUE)
    for(i in seq_along(json_dir)){
        x <- readLines(json_dir[i])
        x <- gsub("\\\\", "/", x)
        writeLines(x, con = json_dir[i])
    }
}

################################################################################
#' Compile kallisto runs into a table
#'
#' After generating transcript/feature abundance results using kallisto for a
#' batch of samples, read these abundance values into a table with transcripts
#' as rows and samples as columns
#'
#' @param kallisto_log list, generated by \code{batchKallisto}.
#'
#' @param feature a character indicating which value to extract from abundance files.
#' Fields available are "length", "eff_length", "est_counts", "tpm"
#'
#' @details This function expects to find only one set of kallisto abundance
#' results per directory; multiple abundance results in a given directory will
#' be problematic.
#'
#' @return a table of values, samples along columns and transcripts along rows
#'
#' @name kallisto-wrapper
#' @rdname kallisto-wrapper
#'
#' @export
#'
generate_table <- function(kallisto_log, feature){
    if ( !is.list(kallisto_log) )
        stop("The kallisto_log argument should be a list returned by runKallisto()")
    samples <- names(kallisto_log)
    directories <- sapply(kallisto_log, function(x) {x$output_dir})
    logs <- lapply(kallisto_log, function(x) {x$kallisto_log})

    ## Can only check kallisto fail if log provided
    kallisto_fail <- sapply(logs, function(x) {
        any(grepl("[wW]arning|[eE]rror", x))})
    if ( any(kallisto_fail) ) {
        warning(paste0("The kallisto job failed for the following samples:\n ",
                       paste0(names(logs)[kallisto_fail], collapse = "\n"),
                       "\n It is recommended that you inspect kallisto_log for these samples."))
    }
    samples <- samples[!kallisto_fail]
    directories <- directories[!kallisto_fail]

    if ( !all(dir.exists(directories)) )
        stop("Some of the desired directories to import do not exist!")

    tsv.paths <- paste0(directories, "/abundance.tsv")
    #if(any(!file.exists(tsv.paths))){
    #    warning(paste0("The following abundance files were not found:\n ",
    #                   paste0(tsv.paths[!file.exists(tsv.paths)], collapse = "\n"),
    #                   "\n Proceeding to exclude these samples"))
    #}

    quant <- NULL
    s1 <- read.table(tsv.paths[1], header = T, stringsAsFactors = F)[,1]

    for(i in seq_along(tsv.paths)){
        abundance <- read.table(tsv.paths[i], header = T, row.names = 1)
        quant <- cbind(quant, abundance[,feature])
    }
    rownames(quant) <- s1
    colnames(quant) <- samples

    return(quant)
}

